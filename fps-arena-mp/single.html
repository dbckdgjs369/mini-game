<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS Arena - Ïã±Í∏Ä ÌîåÎ†àÏù¥Ïñ¥</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #gameContainer { position: relative; width: 100vw; height: 100vh; }
        
        /* ÌÅ¨Î°úÏä§Ìó§Ïñ¥ */
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 20px; height: 20px; pointer-events: none; z-index: 100; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(0, 255, 0, 0.8); }
        #crosshair::before { width: 2px; height: 20px; left: 50%; transform: translateX(-50%); }
        #crosshair::after { width: 20px; height: 2px; top: 50%; transform: translateY(-50%); }
        #crosshair::before, #crosshair::after { box-shadow: 0 0 10px rgba(0, 255, 0, 0.5); }
        
        /* ÌûàÌä∏ÎßàÏª§ */
        #hitmarker { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 40px; height: 40px; pointer-events: none; z-index: 101; display: none; }
        #hitmarker.show { display: block; animation: hitmarkerAnim 0.15s ease-out; }
        #hitmarker::before, #hitmarker::after { content: ''; position: absolute; width: 100%; height: 4px; background: #ff0000; top: 50%; left: 0; }
        #hitmarker::before { transform: translateY(-50%) rotate(45deg); }
        #hitmarker::after { transform: translateY(-50%) rotate(-45deg); }
        @keyframes hitmarkerAnim { 0% { transform: translate(-50%, -50%) scale(1.5); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 0; } }
        
        /* UI */
        #ui { position: absolute; top: 20px; left: 20px; color: #fff; z-index: 100; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); }
        #ui h2 { font-size: 24px; margin-bottom: 10px; color: #0f0; }
        .stat { font-size: 18px; margin: 5px 0; }
        .hp-bar { width: 200px; height: 20px; background: #333; border: 2px solid #555; margin-top: 10px; position: relative; }
        .hp-fill { height: 100%; background: linear-gradient(90deg, #f00, #ff0, #0f0); transition: width 0.2s; }
        .hp-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 12px; font-weight: bold; color: #fff; }
        
        /* ÏãúÏûë/Í≤åÏûÑÏò§Î≤Ñ ÌôîÎ©¥ */
        #startScreen, #gameOverScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 200; color: #fff; }
        #gameOverScreen { display: none; }
        h1 { font-size: 64px; margin-bottom: 20px; text-shadow: 0 0 20px #0f0; color: #0f0; }
        .btn { padding: 15px 40px; font-size: 24px; background: transparent; border: 3px solid #0f0; color: #0f0; cursor: pointer; transition: all 0.3s; margin: 10px; }
        .btn:hover { background: #0f0; color: #000; box-shadow: 0 0 30px #0f0; }
        .controls { margin-top: 30px; text-align: center; color: #aaa; }
        .controls p { margin: 5px 0; }
        
        /* ÌÇ¨ ÌîºÎìú */
        #killFeed { position: absolute; top: 20px; right: 20px; z-index: 100; text-align: right; }
        .kill-message { color: #ff0; font-size: 16px; margin: 5px 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); animation: fadeOut 3s forwards; }
        @keyframes fadeOut { 0% { opacity: 1; } 70% { opacity: 1; } 100% { opacity: 0; } }
        
        /* Î¨¥Í∏∞ */
        #weapon { position: absolute; bottom: 50px; right: 100px; width: 200px; height: 100px; z-index: 50; }
        .gun { width: 100%; height: 100%; background: linear-gradient(135deg, #444, #222); border-radius: 10px; position: relative; transform-origin: bottom center; transition: transform 0.1s; }
        .gun.recoil { transform: rotateX(-15deg) translateY(-10px); }
        .gun-barrel { position: absolute; top: 20px; left: -30px; width: 80px; height: 20px; background: #111; border-radius: 5px; }
        .muzzle-flash { position: absolute; top: 10px; left: -50px; width: 30px; height: 40px; background: radial-gradient(ellipse, #ff0, #f80, transparent); opacity: 0; transition: opacity 0.05s; }
        .muzzle-flash.active { opacity: 1; }
        
        /* Î¶¨Ïä§Ìè∞ ÌôîÎ©¥ */
        #respawnScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 300; color: #fff; }
        #respawnScreen.show { display: flex; }
        #respawnCount { font-size: 80px; font-weight: bold; color: #ff6600; margin-bottom: 20px; }
        #respawnText { font-size: 24px; color: #aaa; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="crosshair"></div>
        <div id="hitmarker"></div>
        
        <div id="respawnScreen">
            <div id="respawnCount">3</div>
            <div id="respawnText">Ï¥à ÌõÑ Î∂ÄÌôú...</div>
        </div>
        
        <div id="ui" style="display: none;">
            <h2>üéÆ FPS ARENA</h2>
            <div class="stat">ÌÇ¨: <span id="kills">0</span> / Îç∞Ïä§: <span id="deaths">0</span></div>
            <div class="stat">Ï†êÏàò: <span id="score">0</span></div>
            <div class="hp-bar">
                <div class="hp-fill" id="hpFill" style="width: 100%"></div>
                <div class="hp-text" id="hpText">100/100</div>
            </div>
            <div class="stat" style="margin-top: 10px;">ÌÉÑÏïΩ: <span id="ammo">30</span>/30</div>
        </div>
        
        <div id="killFeed"></div>
        
        <div id="weapon" style="display: none;">
            <div class="gun" id="gun">
                <div class="gun-barrel"></div>
                <div class="muzzle-flash" id="muzzleFlash"></div>
            </div>
        </div>
        
        <div id="startScreen">
            <h1>üî´ FPS ARENA</h1>
            <p style="font-size: 20px; margin-bottom: 30px;">Ïã±Í∏Ä ÌîåÎ†àÏù¥Ïñ¥ - Ìä∏ ÎåÄÏ†Ñ</p>
            <button class="btn" onclick="startGame()">Í≤åÏûÑ ÏãúÏûë</button>
            <div class="controls">
                <p><strong>Ï°∞ÏûëÎ≤ï</strong></p>
                <p>WASD - Ïù¥Îèô</p>
                <p>ÎßàÏö∞Ïä§ - Ï°∞Ï§Ä</p>
                <p>Ï¢åÌÅ¥Î¶≠ - Î∞úÏÇ¨</p>
                <p>R - Ïû¨Ïû•Ï†Ñ</p>
                <p>Space - Ï†êÌîÑ</p>
                <p>Shift - Îã¨Î¶¨Í∏∞</p>
            </div>
        </div>
        
        <div id="gameOverScreen">
            <h1>Í≤åÏûÑ Ï¢ÖÎ£å</h1>
            <p style="font-size: 24px; margin: 20px;">ÏµúÏ¢Ö Ï†êÏàò: <span id="finalScore">0</span></p>
            <p style="font-size: 20px; margin: 10px;">ÌÇ¨: <span id="finalKills">0</span> / Îç∞Ïä§: <span id="finalDeaths">0</span></p>
            <button class="btn" onclick="location.reload()">Îã§ÏãúÌïòÍ∏∞</button>
            <button class="btn" onclick="location.href='index.html'" style="border-color: #888; color: #888;">Î©îÏù∏ Î©îÎâ¥</button>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Í≤åÏûÑ Î™®Îìà -->
    <script src="js/core.js"></script>
    <script src="js/walls.js"></script>
    <script src="js/healthpack.js"></script>

    <script>
        // ============================================
        // Ïã±Í∏Ä ÌîåÎ†àÏù¥Ïñ¥ Î°úÏßÅ
        // ============================================
        
        let player, bot;
        let isPointerLocked = false;
        const keys = {};
        let mouseX = 0, mouseY = 0;
        let playerVelocity = new THREE.Vector3();
        let playerOnGround = false;
        
        // Î¨¥Í∏∞ ÏÑ§Ï†ï
        const WEAPONS = {
            1: { name: 'rifle', damage: 20, fireRate: 100, ammo: 30, reloadTime: 2000, zoom: 1 },
            2: { name: 'sniper', damage: 80, fireRate: 1500, ammo: 5, reloadTime: 3000, zoom: 0.3 },
            3: { name: 'knife', damage: 50, fireRate: 500, ammo: Infinity, reloadTime: 0, zoom: 1, melee: true }
        };
        let currentWeapon = 1;
        let isZoomed = false;
        let originalFOV = 75;
        
        // ÏûÖÎ†• Ïù¥Î≤§Ìä∏
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            if (!window.FPSCore.gameState().isPlaying || !player || player.isDead) return;
            
            // Ïû¨Ïû•Ï†Ñ
            if (e.code === 'KeyR') {
                player.reload();
            }
            
            // Î¨¥Í∏∞ Î≥ÄÍ≤Ω
            if (e.code === 'Digit1') switchWeapon(1);
            if (e.code === 'Digit2') switchWeapon(2);
            if (e.code === 'Digit3') switchWeapon(3);
        });
        
        document.addEventListener('keyup', (e) => keys[e.code] = false);
        
        // ÎßàÏö∞Ïä§ ÏûÖÎ†•
        document.addEventListener('mousedown', (e) => {
            if (!window.FPSCore.gameState().isPlaying || !isPointerLocked || !player || player.isDead) return;
            
            if (e.button === 0) {
                // Ï¢åÌÅ¥Î¶≠: Î∞úÏÇ¨
                player.fire();
            } else if (e.button === 2) {
                // Ïö∞ÌÅ¥Î¶≠: Ïä§ÏΩîÌîÑ (Ï†ÄÍ≤©Ï¥ùÎßå)
                if (currentWeapon === 2) toggleZoom(true);
            }
        });
        
        document.addEventListener('mouseup', (e) => {
            if (e.button === 2) {
                // Ïö∞ÌÅ¥Î¶≠ Ìï¥Ï†ú: Ïä§ÏΩîÌîÑ Ìï¥Ï†ú
                toggleZoom(false);
            }
        });
        
        // Ïö∞ÌÅ¥Î¶≠ Î©îÎâ¥ Î∞©ÏßÄ
        document.addEventListener('contextmenu', (e) => e.preventDefault());
        
        document.addEventListener('mousemove', (e) => {
            if (isPointerLocked && window.FPSCore.gameState().isPlaying) {
                const CONFIG = window.FPSCore.CONFIG;
                const sensitivity = isZoomed ? CONFIG.mouseSensitivity * 0.5 : CONFIG.mouseSensitivity;
                mouseX -= e.movementX * sensitivity;
                mouseY -= e.movementY * sensitivity;
                mouseY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouseY));
            }
        });
        
        // Í≤åÏûÑ ÏãúÏûë
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('weapon').style.display = 'block';
            
            // ÏΩîÏñ¥ Ï¥àÍ∏∞Ìôî
            const core = window.FPSCore.initCore('gameContainer');
            const camera = core.camera;
            
            // Î∞îÎã• ÏÉùÏÑ±
            window.FPSCore.createFloor();
            
            // Ïô∏Í≥Ω Î≤Ω (ÌååÍ¥¥ Î∂àÍ∞Ä)
            window.FPSCore.createStaticWall(0, 2.5, -25, 50, 5, 2);
            window.FPSCore.createStaticWall(0, 2.5, 25, 50, 5, 2);
            window.FPSCore.createStaticWall(-25, 2.5, 0, 2, 5, 50);
            window.FPSCore.createStaticWall(25, 2.5, 0, 2, 5, 50);
            
            // ÎÇ¥Î∂Ä Î≤Ω (ÌååÍ¥¥ Í∞ÄÎä•)
            window.FPSWalls.initWalls();
            window.FPSWalls.createDestructibleWall(0, 2, 0, 6, 4, 6);
            window.FPSWalls.createDestructibleWall(-10, 1.5, -10, 4, 3, 4);
            window.FPSWalls.createDestructibleWall(10, 1.5, 10, 4, 3, 4);
            window.FPSWalls.createDestructibleWall(-10, 1.5, 10, 4, 3, 4);
            window.FPSWalls.createDestructibleWall(10, 1.5, -10, 4, 3, 4);
            
            // ÌûêÌå© Ï¥àÍ∏∞Ìôî
            window.FPSHealthPack.initHealthPack();
            window.FPSHealthPack.spawnHealthPack(new THREE.Vector3(0, 0.5, 0));
            
            // Ï¥àÍ∏∞ Î¨¥Í∏∞ ÏÑ§Ï†ï
            currentWeapon = 1;
            
            // ÌîåÎ†àÏù¥Ïñ¥ ÏÉùÏÑ±
            player = new Character('Player', new THREE.Vector3(-15, 0.1, -15), false);
            camera.position.set(-15, 1.6, -15);
            
            // Î¥á ÏÉùÏÑ±
            bot = new Character('Bot', new THREE.Vector3(15, 0.1, 15), true);
            bot.ai = new BotAI(bot);
            
            // Í≤åÏûÑ ÏÉÅÌÉú ÏÑ§Ï†ï
            window.FPSCore.setGameState('isPlaying', true);
            window.FPSCore.updateUI(player);
            
            // Ìè¨Ïù∏ÌÑ∞ ÎùΩ
            core.renderer.domElement.requestPointerLock();
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === core.renderer.domElement;
            });
            
            // Îñ®Ïñ¥ÏßÄÎäî Î≤Ω Ï£ºÍ∏∞Ï†Å ÏÉùÏÑ±
            setInterval(() => {
                if (window.FPSCore.gameState().isPlaying) {
                    window.FPSWalls.spawnFallingWall();
                }
            }, 15000);
            
            // Í≤åÏûÑ Î£®ÌîÑ
            animate();
        }
        
        // Í≤åÏûÑ Î£®ÌîÑ
        function animate() {
            requestAnimationFrame(animate);
            
            const gameState = window.FPSCore.gameState();
            if (gameState.isPlaying) {
                // ÌîåÎ†àÏù¥Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏
                if (player && !player.isDead) {
                    updatePlayer();
                }
                
                // Î¥á ÏóÖÎç∞Ïù¥Ìä∏
                if (bot && bot.ai) bot.ai.update();
                if (bot) bot.updateHealthBar();
                
                // Î≤Ω/ÌûêÌå© ÏóÖÎç∞Ïù¥Ìä∏
                window.FPSWalls.updateFallingWalls((damage) => {
                    if (player && !player.isDead) {
                        player.takeDamage(damage, bot);
                    }
                });
                
                window.FPSHealthPack.checkHealthPackPickup((amount) => {
                    window.FPSCore.updateUI(player);
                });
                window.FPSHealthPack.updateHealthPackAnimation();
                
                // Ï¥ùÏïå/ÌååÌã∞ÌÅ¥ ÏóÖÎç∞Ïù¥Ìä∏
                updateBullets();
                window.FPSCore.updateParticles();
            }
            
            window.FPSCore.renderer().render(window.FPSCore.scene(), window.FPSCore.camera());
        }
        
        // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô
        function updatePlayer() {
            const camera = window.FPSCore.camera();
            const CONFIG = window.FPSCore.CONFIG;
            
            // ÌöåÏ†Ñ
            camera.rotation.set(mouseY, mouseX, 0, 'YXZ');
            
            // Ïù¥Îèô
            const speed = keys['ShiftLeft'] ? CONFIG.runSpeed : CONFIG.playerSpeed;
            const direction = new THREE.Vector3();
            
            if (keys['KeyW']) direction.z -= 1;
            if (keys['KeyS']) direction.z += 1;
            if (keys['KeyA']) direction.x -= 1;
            if (keys['KeyD']) direction.x += 1;
            
            direction.normalize().multiplyScalar(speed);
            direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y);
            
            // Ï∂©Îèå Ï≤¥ÌÅ¨
            const newPos = camera.position.clone().add(direction);
            newPos.y = camera.position.y;
            if (!checkWallCollision(newPos)) {
                camera.position.x = newPos.x;
                camera.position.z = newPos.z;
            }
            
            // Ï§ëÎ†•
            playerVelocity.y -= CONFIG.gravity;
            camera.position.y += playerVelocity.y;
            
            if (camera.position.y <= 1.6) {
                camera.position.y = 1.6;
                playerVelocity.y = 0;
                playerOnGround = true;
            }
            
            // Ï†êÌîÑ
            if (keys['Space'] && playerOnGround) {
                playerVelocity.y = CONFIG.jumpForce;
                playerOnGround = false;
            }
            
            // ÌîåÎ†àÏù¥Ïñ¥ Î©îÏâ¨ ÏúÑÏπò ÎèôÍ∏∞Ìôî
            if (player && player.mesh) {
                player.mesh.position.x = camera.position.x;
                player.mesh.position.z = camera.position.z;
            }
        }
        
        // Î¨¥Í∏∞ Î≥ÄÍ≤Ω
        function switchWeapon(weaponNum) {
            if (weaponNum < 1 || weaponNum > 3) return;
            
            // ÌòÑÏû¨ Î¨¥Í∏∞ ÌÉÑÏïΩ Ï†ÄÏû•
            if (player) {
                player.weaponAmmo[currentWeapon] = player.ammo;
            }
            
            currentWeapon = weaponNum;
            
            // ÏÉà Î¨¥Í∏∞ ÌÉÑÏïΩ Î∂àÎü¨Ïò§Í∏∞
            if (player) {
                player.ammo = player.weaponAmmo[weaponNum];
            }
            
            // UI ÏóÖÎç∞Ïù¥Ìä∏
            updateWeaponUI();
            window.FPSCore.updateUI(player);
            
            // Ïä§ÏΩîÌîÑ Ìï¥Ï†ú
            toggleZoom(false);
            
            // Î¨¥Í∏∞ Î≥ÄÍ≤Ω ÏÇ¨Ïö¥Îìú
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.value = 800;
                osc.type = 'sine';
                gain.gain.value = 0.2;
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } catch (e) {}
        }
        
        // Î¨¥Í∏∞ UI ÏóÖÎç∞Ïù¥Ìä∏
        function updateWeaponUI() {
            const weapon = WEAPONS[currentWeapon];
            const weaponNames = { 1: 'ÏÜåÏ¥ù', 2: 'Ï†ÄÍ≤©Ï¥ù', 3: 'Ïπº' };
            
            // Í∏∞Ï°¥ Î¨¥Í∏∞ ÌëúÏãú Ï†úÍ±∞
            const existing = document.getElementById('weaponDisplay');
            if (existing) existing.remove();
            
            // ÏÉà Î¨¥Í∏∞ ÌëúÏãú
            const display = document.createElement('div');
            display.id = 'weaponDisplay';
            display.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0,0,0,0.7);
                padding: 10px 30px;
                border-radius: 10px;
                border: 2px solid #0f0;
                color: #0f0;
                font-size: 20px;
                font-weight: bold;
                z-index: 150;
                text-align: center;
            `;
            display.innerHTML = `
                <div style="font-size: 14px; color: #888; margin-bottom: 5px;">[1] ÏÜåÏ¥ù  [2] Ï†ÄÍ≤©Ï¥ù  [3] Ïπº</div>
                <div>${weaponNames[currentWeapon]}</div>
                <div style="font-size: 14px; color: #aaa;">${weapon.melee ? 'Í∑ºÏ†ë Î¨¥Í∏∞' : `ÌÉÑÏïΩ: ${weapon.ammo}`}</div>
            `;
            document.body.appendChild(display);
            
            // 2Ï¥à ÌõÑ ÌéòÏù¥Îìú ÏïÑÏõÉ
            setTimeout(() => {
                if (display.parentNode) {
                    display.style.transition = 'opacity 0.5s';
                    display.style.opacity = '0';
                    setTimeout(() => display.remove(), 500);
                }
            }, 2000);
        }
        
        // Ïä§ÏΩîÌîÑ ÌÜ†Í∏Ä
        function toggleZoom(zoomIn) {
            if (currentWeapon !== 2) return; // Ï†ÄÍ≤©Ï¥ùÎßå Í∞ÄÎä•
            
            const camera = window.FPSCore.camera();
            isZoomed = zoomIn;
            
            if (zoomIn) {
                // Ï§å Ïù∏
                camera.fov = 20; // Ï¢ÅÏùÄ ÏãúÏïº
                
                // Ïä§ÏΩîÌîÑ UI
                const scope = document.createElement('div');
                scope.id = 'scopeOverlay';
                scope.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 300px;
                    height: 300px;
                    border: 2px solid rgba(0,255,0,0.8);
                    border-radius: 50%;
                    z-index: 90;
                    pointer-events: none;
                    box-shadow: 0 0 20px rgba(0,255,0,0.3);
                `;
                scope.innerHTML = `
                    <div style="position: absolute; top: 50%; left: 0; width: 100%; height: 2px; background: rgba(0,255,0,0.5);"></div>
                    <div style="position: absolute; top: 0; left: 50%; width: 2px; height: 100%; background: rgba(0,255,0,0.5);"></div>
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 10px; height: 10px; background: rgba(0,255,0,0.8); border-radius: 50%;"></div>
                `;
                document.body.appendChild(scope);
                
                // ÌôîÎ©¥ Ïñ¥Îë°Í≤å
                const vignette = document.createElement('div');
                vignette.id = 'scopeVignette';
                vignette.style.cssText = `
                    position: fixed;
                    top: 0; left: 0; width: 100%; height: 100%;
                    background: radial-gradient(circle at center, transparent 150px, rgba(0,0,0,0.7) 300px);
                    z-index: 80;
                    pointer-events: none;
                `;
                document.body.appendChild(vignette);
                
            } else {
                // Ï§å ÏïÑÏõÉ
                camera.fov = originalFOV;
                
                // Ïä§ÏΩîÌîÑ UI Ï†úÍ±∞
                const scope = document.getElementById('scopeOverlay');
                if (scope) scope.remove();
                const vignette = document.getElementById('scopeVignette');
                if (vignette) vignette.remove();
            }
            
            camera.updateProjectionMatrix();
        }
        
        // Ìó§ÎìúÏÉ∑ ÎßàÏª§ ÌëúÏãú
        function showHeadshotMarker() {
            const marker = document.createElement('div');
            marker.textContent = 'HEADSHOT!';
            marker.style.cssText = `
                position: fixed;
                top: 40%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 48px;
                font-weight: bold;
                color: #ff0000;
                text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000;
                z-index: 200;
                pointer-events: none;
                animation: headshotAnim 1s ease-out forwards;
            `;
            document.body.appendChild(marker);
            
            // Ìó§ÎìúÏÉ∑ ÏÇ¨Ïö¥Îìú
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.frequency.value = 1200;
                oscillator.type = 'square';
                gainNode.gain.value = 0.3;
                oscillator.start();
                oscillator.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                oscillator.stop(audioCtx.currentTime + 0.3);
            } catch (e) {}
            
            setTimeout(() => marker.remove(), 1000);
        }
        
        // Ìó§ÎìúÏÉ∑ Ïï†ÎãàÎ©îÏù¥ÏÖò CSS
        const style = document.createElement('style');
        style.textContent = `
            @keyframes headshotAnim {
                0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
                20% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
                100% { transform: translate(-50%, -50%) scale(1) translateY(-50px); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        // Î≤Ω Ï∂©Îèå Ï≤¥ÌÅ¨ (Î∞îÎã• Ï†úÏô∏)
        function checkWallCollision(position) {
            const playerBox = new THREE.Box3(
                new THREE.Vector3(position.x - 0.3, position.y - 1.6, position.z - 0.3),
                new THREE.Vector3(position.x + 0.3, position.y + 0.1, position.z + 0.3)
            );
            
            const mapObjects = window.FPSCore.mapObjects();
            for (const obj of mapObjects) {
                // Î∞îÎã•ÏùÄ Î¨¥Ïãú
                if (obj.userData && obj.userData.isFloor) continue;
                
                const box = new THREE.Box3().setFromObject(obj);
                if (box.intersectsBox(playerBox)) return true;
            }
            return false;
        }
        
        // Ï¥ùÏïå ÏóÖÎç∞Ïù¥Ìä∏
        function updateBullets() {
            const bullets = window.FPSCore.bullets();
            const scene = window.FPSCore.scene();
            
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                
                // Ïù¥Ï†Ñ ÏúÑÏπò Ï†ÄÏû•
                const prevPos = b.mesh.position.clone();
                
                // Ïù¥Îèô
                const moveVec = b.direction.clone().multiplyScalar(b.speed);
                b.mesh.position.add(moveVec);
                b.life--;
                
                let hit = false;
                let hitCharacter = false;
                
                // RaycastingÏúºÎ°ú Ï∂©Îèå Ï≤¥ÌÅ¨ (ÌîÑÎ†àÏûÑ ÏÇ¨Ïù¥ ÌÜµÍ≥º Î∞©ÏßÄ)
                const rayDir = b.direction.clone();
                const rayDist = prevPos.distanceTo(b.mesh.position);
                const raycaster = new THREE.Raycaster(prevPos, rayDir, 0, rayDist + 0.5);
                
                // Ï∫êÎ¶≠ÌÑ∞ Ï∂©Îèå (Raycasting)
                [player, bot].forEach(char => {
                    if (!hit && char !== b.owner && !char.isDead) {
                        const box = new THREE.Box3().setFromObject(char.mesh);
                        
                        if (raycaster.ray.intersectsBox(box)) {
                            // Ï∂©Îèå ÏßÄÏ†ê Í≥ÑÏÇ∞
                            const hitPoint = raycaster.ray.intersectBox(box, new THREE.Vector3());
                            
                            // Ìó§ÎìúÏÉ∑ Ï≤¥ÌÅ¨
                            const headHeight = char.mesh.position.y + 1.4;
                            const isHeadshot = hitPoint && hitPoint.y >= headHeight;
                            
                            // Îç∞ÎØ∏ÏßÄ Í≥ÑÏÇ∞
                            const weaponDamage = b.owner.isBot ? WEAPONS[1].damage : WEAPONS[currentWeapon].damage;
                            const damage = isHeadshot ? weaponDamage * 2 : weaponDamage;
                            
                            char.takeDamage(damage, b.owner, isHeadshot);
                            hit = true;
                            hitCharacter = true;
                            
                            if (isHeadshot && !b.owner.isBot) {
                                showHeadshotMarker();
                            }
                        }
                    }
                });
                
                // ÌûàÌä∏ÎßàÏª§
                if (hitCharacter && !b.owner.isBot) {
                    window.FPSCore.showHitmarker();
                }
                
                // Î≤Ω Ï∂©Îèå (Í∏∞Ï°¥ Î∞©Ïãù Ïú†ÏßÄ)
                if (!hit) {
                    const wallHit = window.FPSWalls.checkBulletWallCollision(b.mesh.position);
                    if (wallHit.hit) {
                        hit = true;
                        if (wallHit.wall) {
                            window.FPSWalls.damageWall(wallHit.wall, 10);
                        }
                    }
                }
                
                // Ï†úÍ±∞
                if (hit || b.life <= 0 || b.mesh.position.y < 0) {
                    if (hit) window.FPSCore.createImpactEffect(b.mesh.position);
                    scene.remove(b.mesh);
                    bullets.splice(i, 1);
                }
            }
        }
        
        // Ï∫êÎ¶≠ÌÑ∞ ÌÅ¥ÎûòÏä§
        class Character {
            constructor(name, position, isBot) {
                this.name = name;
                this.isBot = isBot;
                this.maxHealth = window.FPSCore.CONFIG.maxHealth;
                this.health = this.maxHealth;
                this.isDead = false;
                this.lastShotTime = 0;
                this.respawnTime = 3000;
                
                // Î¨¥Í∏∞Î≥Ñ ÌÉÑÏïΩ Ïàò Ï†ÄÏû•
                this.weaponAmmo = {
                    1: WEAPONS[1].ammo,  // ÏÜåÏ¥ù: 30
                    2: WEAPONS[2].ammo,  // Ï†ÄÍ≤©Ï¥ù: 5
                    3: WEAPONS[3].ammo   // Ïπº: Infinity
                };
                this.ammo = this.weaponAmmo[1]; // Í∏∞Î≥∏ ÏÜåÏ¥ù
                
                // Î©îÏâ¨ ÏÉùÏÑ±
                const geo = new THREE.BoxGeometry(0.6, 1.8, 0.4);
                const mat = new THREE.MeshLambertMaterial({ color: isBot ? 0xff3333 : 0x3333ff });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.position.copy(position);
                this.mesh.position.y = 0.9;
                this.mesh.castShadow = true;
                window.FPSCore.scene().add(this.mesh);
                
                // HP Î∞î
                this.createHealthBar();
            }
            
            createHealthBar() {
                this.healthBarGroup = new THREE.Group();
                this.healthBarGroup.position.y = 2.2;
                
                const bgGeo = new THREE.PlaneGeometry(1, 0.15);
                const bgMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
                const bg = new THREE.Mesh(bgGeo, bgMat);
                this.healthBarGroup.add(bg);
                
                const fillGeo = new THREE.PlaneGeometry(0.95, 0.1);
                const fillMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                this.healthBar = new THREE.Mesh(fillGeo, fillMat);
                this.healthBar.position.x = -0.475;
                this.healthBar.geometry.translate(0.475, 0, 0.01);
                this.healthBarGroup.add(this.healthBar);
                
                this.mesh.add(this.healthBarGroup);
                this.healthBarGroup.visible = false;
            }
            
            updateHealthBar() {
                if (this.isBot && this.healthBarGroup) {
                    this.healthBarGroup.lookAt(window.FPSCore.camera().position);
                }
                const scale = this.health / this.maxHealth;
                this.healthBar.scale.x = Math.max(0, scale);
                this.healthBar.material.color.setHSL(scale * 0.33, 1, 0.5);
            }
            
            canFire() {
                const weapon = WEAPONS[currentWeapon];
                const now = Date.now();
                
                // ÏπºÏùÄ Ìï≠ÏÉÅ Î∞úÏÇ¨ Í∞ÄÎä• (Í∑ºÏ†ë)
                if (weapon.melee) {
                    return now - this.lastShotTime > weapon.fireRate;
                }
                
                // Ï¥ùÏùÄ ÌÉÑÏïΩ ÌôïÏù∏
                return now - this.lastShotTime > weapon.fireRate && this.ammo > 0;
            }
            
            fire() {
                const weapon = WEAPONS[currentWeapon];
                
                if (!this.canFire()) {
                    if (!weapon.melee && this.ammo <= 0) this.reload();
                    return false;
                }
                
                this.lastShotTime = Date.now();
                
                let startPos;
                let direction;
                
                if (this.isBot) {
                    // Ìä∏: Î©îÏâ¨ ÏúÑÏπò + Îàà ÎÜíÏù¥ÏóêÏÑú Î∞úÏÇ¨ (Î¥áÏùÄ ÏÜåÏ¥ùÎßå ÏÇ¨Ïö©)
                    startPos = this.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0));
                    direction = window.FPSCore.camera().position.clone().sub(startPos).normalize();
                    const spread = (1 - window.FPSCore.CONFIG.botAccuracy) * 0.1;
                    direction.x += (Math.random() - 0.5) * spread;
                    direction.y += (Math.random() - 0.5) * spread;
                    direction.normalize();
                    
                    // Î¥á ÌÉÑÏïΩ Í∞êÏÜå
                    if (this.weaponAmmo[1] > 0) {
                        this.weaponAmmo[1]--;
                    }
                } else {
                    // ÌîåÎ†àÏù¥Ïñ¥: ÏπºÏ≤ò ÏúÑÏπòÏóêÏÑú Î∞úÏÇ¨ (Ï°∞Ï§ÄÏÑ†Í≥º ÏùºÏπò)
                    const camera = window.FPSCore.camera();
                    startPos = camera.position.clone();
                    
                    // getWorldDirection ÏÇ¨Ïö© (Îçî Ï†ïÌôïÌïú Î∞©Ìñ• Í≥ÑÏÇ∞)
                    direction = new THREE.Vector3();
                    camera.getWorldDirection(direction);
                    
                    if (!weapon.melee) {
                        this.ammo--;
                        this.weaponAmmo[currentWeapon] = this.ammo; // Ìï¥Îãπ Î¨¥Í∏∞ ÌÉÑÏïΩ Ï†ÄÏû•
                        window.FPSCore.showMuzzleFlash();
                        window.FPSCore.updateUI(this);
                        updateWeaponUI();
                    }
                }
                
                if (weapon.melee) {
                    // Ïπº: Í∑ºÏ†ë Í≥µÍ≤©
                    this.meleeAttack();
                } else {
                    // Ï¥ù: Ï¥ùÏïå Î∞úÏÇ¨ (Ï†ÄÍ≤©Ï¥ùÏùÄ 300m, ÎÇòÎ®∏ÏßÄÎäî 100m)
                    const bulletLife = currentWeapon === 2 ? 300 : 100;
                    window.FPSCore.createBullet(startPos, direction, this, bulletLife);
                }
                
                return true;
            }
            
            meleeAttack() {
                // Ïπº ÌúòÎëêÎ•¥Í∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò
                const camera = window.FPSCore.camera();
                const weaponEl = document.getElementById('weapon');
                if (weaponEl) {
                    weaponEl.style.transform = 'rotateZ(-45deg)';
                    setTimeout(() => {
                        weaponEl.style.transform = 'rotateZ(0deg)';
                    }, 200);
                }
                
                // Í∑ºÏ†ë Í≥µÍ≤© Î≤îÏúÑ Ï≤¥ÌÅ¨
                const attackRange = 2.5;
                const myPos = this.mesh.position.clone();
                
                [player, bot].forEach(target => {
                    if (target === this || target.isDead) return;
                    
                    const dist = myPos.distanceTo(target.mesh.position);
                    if (dist < attackRange) {
                        // Î∞©Ìñ• Ï≤¥ÌÅ¨ (Ï†ïÎ©¥Ïóê ÏûàÎäîÏßÄ)
                        const toTarget = target.mesh.position.clone().sub(myPos).normalize();
                        const myForward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), 
                            this.isBot ? this.mesh.rotation.y : window.FPSCore.camera().rotation.y);
                        
                        if (toTarget.dot(myForward) > 0.5) { // Ï†ïÎ©¥ 60ÎèÑ Î≤îÏúÑ
                            target.takeDamage(WEAPONS[3].damage, this);
                            if (!this.isBot) window.FPSCore.showHitmarker();
                        }
                    }
                });
            }
            
            reload() {
                const weapon = WEAPONS[currentWeapon];
                if (weapon.melee || this.ammo >= weapon.ammo) return;
                
                if (!this.isBot) {
                    document.getElementById('ammo').textContent = 'Ïû•Ï†ÑÏ§ë...';
                }
                
                setTimeout(() => {
                    this.ammo = weapon.ammo;
                    this.weaponAmmo[currentWeapon] = this.ammo; // Ìï¥Îãπ Î¨¥Í∏∞ ÌÉÑÏïΩ Ï†ÄÏû•
                    if (!this.isBot) {
                        window.FPSCore.updateUI(this);
                        updateWeaponUI();
                    }
                }, weapon.reloadTime);
            }
            
            takeDamage(damage, attacker, isHeadshot = false) {
                if (this.isDead) return;
                
                this.health -= damage;
                this.updateHealthBar();
                this.healthBarGroup.visible = true;
                
                // ÌîºÍ≤© Ìö®Í≥º
                const flash = new THREE.PointLight(0xff0000, 2, 5);
                flash.position.copy(this.mesh.position);
                flash.position.y += 1;
                window.FPSCore.scene().add(flash);
                setTimeout(() => window.FPSCore.scene().remove(flash), 100);
                
                if (!this.isBot) {
                    // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä ÎßûÏúºÎ©¥ ÌôîÎ©¥ Ìö®Í≥º
                    const bgFlash = document.createElement('div');
                    bgFlash.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(255,0,0,0.3);pointer-events:none;z-index:250;';
                    document.body.appendChild(bgFlash);
                    setTimeout(() => bgFlash.remove(), 100);
                }
                
                if (this.health <= 0) {
                    this.die(attacker, isHeadshot);
                }
            }
            
            die(killer) {
                this.isDead = true;
                this.mesh.visible = false;
                this.healthBarGroup.visible = false;
                
                window.FPSCore.addKillFeed(killer.name, this.name);
                
                if (this.isBot) {
                    // Î¥áÏù¥ Ï£ΩÏùå = ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Î¥áÏùÑ Ï£ΩÏûÑ
                    window.FPSCore.setGameState('kills', window.FPSCore.gameState().kills + 1);
                    window.FPSCore.setGameState('score', window.FPSCore.gameState().score + 100);
                } else {
                    // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Ï£ΩÏùå
                    window.FPSCore.setGameState('deaths', window.FPSCore.gameState().deaths + 1);
                }
                // Ìï≠ÏÉÅ ÌîåÎ†àÏù¥Ïñ¥Ïùò UI ÏóÖÎç∞Ïù¥Ìä∏
                window.FPSCore.updateUI(player);
                
                // Î¶¨Ïä§Ìè∞
                if (this.isBot) {
                    setTimeout(() => this.respawn(), this.respawnTime);
                } else {
                    window.FPSCore.startRespawnCountdown(() => this.respawn());
                }
            }
            
            respawn() {
                this.health = this.maxHealth;
                this.isDead = false;
                
                // Î™®Îì† Î¨¥Í∏∞ ÌÉÑÏïΩ Î¶¨ÏÖã
                this.weaponAmmo = {
                    1: WEAPONS[1].ammo,
                    2: WEAPONS[2].ammo,
                    3: WEAPONS[3].ammo
                };
                this.ammo = this.weaponAmmo[currentWeapon];
                
                this.mesh.visible = true;
                this.healthBarGroup.visible = false;
                this.updateHealthBar();
                
                const spawnPoints = [
                    new THREE.Vector3(-15, 0.1, -15),
                    new THREE.Vector3(15, 0.1, 15),
                    new THREE.Vector3(-15, 0.1, 15),
                    new THREE.Vector3(15, 0.1, -15)
                ];
                const spawn = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
                
                this.mesh.position.copy(spawn);
                this.mesh.position.y = 0.9;
                
                if (!this.isBot) {
                    window.FPSCore.camera().position.copy(spawn);
                    window.FPSCore.camera().position.y = 1.6;
                    window.FPSCore.updateUI(this);
                }
            }
        }
        
        // Î¥á AI
        class BotAI {
            constructor(character) {
                this.character = character;
                this.target = null;
                this.moveDirection = new THREE.Vector3();
                this.lastMoveTime = 0;
            }
            
            update() {
                if (this.character.isDead) return;
                
                this.target = player;
                if (!this.target || this.target.isDead) return;
                
                const dist = this.character.mesh.position.distanceTo(this.target.mesh.position);
                
                // ÌîåÎ†àÏù¥Ïñ¥Î•º Ìñ•Ìï¥ ÌöåÏ†Ñ
                this.lookAtTarget();
                
                // ÏÇ¨Í±∞Î¶¨ ÎÇ¥Ïóê ÏûàÏúºÎ©¥ Î∞úÏÇ¨
                if (dist < 30 && this.hasLineOfSight()) {
                    if (Math.random() < 0.1) this.character.fire();
                }
                
                // Ïù¥Îèô
                if (Date.now() - this.lastMoveTime > 1000) {
                    this.lastMoveTime = Date.now();
                    this.moveDirection.set(
                        (Math.random() - 0.5) * 2,
                        0,
                        (Math.random() - 0.5) * 2
                    ).normalize();
                }
                
                const moveSpeed = 0.08;
                const newPos = this.character.mesh.position.clone().add(
                    this.moveDirection.clone().multiplyScalar(moveSpeed)
                );
                
                if (!this.checkCollision(newPos)) {
                    this.character.mesh.position.x = newPos.x;
                    this.character.mesh.position.z = newPos.z;
                }
            }
            
            lookAtTarget() {
                if (!this.target) return;
                const targetPos = this.target.mesh.position.clone();
                targetPos.y = this.character.mesh.position.y;
                this.character.mesh.lookAt(targetPos);
            }
            
            hasLineOfSight() {
                return true; // Îã®ÏàúÌôî
            }
            
            checkCollision(position) {
                const box = new THREE.Box3(
                    new THREE.Vector3(position.x - 0.3, position.y - 0.9, position.z - 0.3),
                    new THREE.Vector3(position.x + 0.3, position.y + 0.9, position.z + 0.3)
                );
                
                const mapObjects = window.FPSCore.mapObjects();
                for (const obj of mapObjects) {
                    const objBox = new THREE.Box3().setFromObject(obj);
                    if (objBox.intersectsBox(box)) return true;
                }
                return false;
            }
        }
    </script>
</body>
</html>
